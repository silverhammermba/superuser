---
layout: chapter
title: 'Part 2: The Internet'
category: part2
---

Almost everyone uses the Internet these days: at home, at work, and even on the
go with their cell phones. Consequently, most people have a vague idea of what
the Internet is. But I think that many people would be surprised at how far from
reality their vague ideas are.

For that reason, we are going to take a similar approach as we did for Part 1
and start by digging down deep to understand the fundamentals before building up
to a complete picture. Let's do it!

You probably are aware that the Internet lets your computer communicate with
other computers around the world. Let's forget about that complicated "around
the world" part and focus just on "computers communicating".

## Protocols ##

We will first consider the simplest possible example of inter-computer
communication: two computers connected with a cable. Each computer can send data
across the cable using electrical signals and each computer can interpret
electrical signals from the cable to get the data out again. Don't worry about
the technical details here, all this means is that each computer can send bytes
to the other one.

But now we're facing a problem similar to one we've faced before. If one
computer receives a bunch of bytes from the other, how does it know what those
bytes mean? This is just like the issue we faced when we were learning about
binary data: bytes can mean very different things depending on how they are
interpreted. The solution there was to agree on different formats for different
data, but this can prove problematic for inter-computer communication.

Suppose one computer sends ten bytes to the other. Is that one ten byte message
or two five byte messages? Normally the receiving computer would use the data
format to determine this, but what if it doesn't know what format we're using?

The current list of digital data formats is **huge** and new formats are being
invented all the time! It is quite common for one computer to understand a
different set of formats than another one. If we simply sent formatted data
across a wire to another computer that doesn't know the format, it would have no
idea how to read the data it receives.

Another problem that occurs with inter-computer communication is unreliable
connections. For _intra_-computer communication - like transferring data from
the hard drive to the RAM - we usually assume that the connection is perfect and
the data will get to their destination intact. On the other hand, when data are
being transmitted to other computers via cables or wireless signals, problems
often occur. Cables can break and signals can get garbled. Even if the receiving
computer understands the data format, it needs to know when a problem is
occurring with the connection so that at the very least it knows that the data
it gets might not be correct. Ideally when a problem occurs we would like to be
able to try again until the data make it across successfully.

To solve this problem, we agree on certain rules for computer communications.
This agreement has a special term:

<div class="alert alert-warning">
A <strong>protocol</strong> defines the rules for exchanging messages between
computers, including the data formats that will be used.
</div>

To get a handle on protocols, we're going to build a protocol bit-by-bit. Our
task will be to transmit a text message of some arbitrary length from one
computer to another. Each step in the protocol will be preceded by a letter,
indicating which computer must complete that step. Let's start with a very
simple protocol

1. A: Every 5 seconds, send the entire message at once using the following
   format:
    * The first four bytes indicate the total number of bytes
	* All remaining bytes are the message, with one byte for each letter. 00 is
	  A, 01 is B, 02 is C, etc. (and 1A and up can be for punctuation, but the
	  details aren't super important here)
2. B: Upon receiving a message, respond with a single byte set to 01.
3. A: Upon receiving a single 01 byte from B, stop sending the message.

This protocol provides basic error protection. If the connection is interrupted
and the message doesn't make it across, A will keep trying to send the message
until it knows for sure that B got it. Usually in situations like this we
additionally define some "give up" condition. The most common would be to give
up after sending the message a certain number of times or after we've been
sending the message repeatedly for a certain amount of time. We'll add that to
the next iteration of the protocol.

## Error Checking ##

One thing this protocol doesn't handle well is errors in transmission that still
allow the message to be received. For example, if we are transmitting wirelessly
atmospheric conditions can garble some of the data, causing B to receive an
altered version of the message. We want to know when such problems occur and
still resend the data. We can solve this by adding a checksum.

<div class="alert alert-warning">
A <strong>checksum</strong> is a function (usually some kind of sum) that takes
a set of data as input and produces a smaller datum as output. The output of
such a function is often also called the <strong>checksum</strong>.
</div>

Now let's add a checksum to the message format for our protocol:

* The first four bytes indicate the total number of bytes, N
* The next N - 5 bytes are the message, with one byte for each letter. 00 is
  A, 01 is B, 02 is C, etc. 1A and above are used for punctuation.
* The final byte is the checksum. It equals the sum of all other bytes, ignoring
  overflow.

Now we can beef up the protocol.

1. A: Every 5 seconds, send the entire message
2. B: Upon receiving a message, compute the checksum (i.e. add up all bytes in
   the message other than the last one). If it equals the last byte in the
   message, respond with 01. Otherwise respond with 00.
3. A: Upon receiving 01 from B, stop sending the message.
4. A: Upon receiving 00 from B, immediately resend the message.
5. A: After sending the message 30 times, give up.

Now B only responds if it calculates a matching checksum. This doesn't give us a
_guarantee_ that the message is correct, but it's pretty close. Recall that a
byte has 256 possible values. Only one of those values is the correct checksum.
That means that if a message gets randomly scrambled in transit, there is only a
1/256 (0.39%) chance that the checksum will still match. Those are pretty good
odds.

Note that the error-checking of B's response is automatic. A knows that B can
only respond with 00 or 01, so the chance of the response being garbled and
still appearing valid is again only 1/256.

B's error-checking also offers an improvement over the last protocol. Rather
than A only resending the message every 5 seconds (in case the message is lost),
B can tell A that the message was garbled in transit. Then A can immediately
resend the message, possibly resulting in a faster successful transmission than
before.

Let's make things even worse. Suppose that the connection is really unreliable
and we expect 1% of transmitted bytes to be garbled. Now our fancy error
checking is of no use. If we ever send a message longer than 100 bytes, we
expect it to arrive incorrectly. Our error checking will probably detect that,
but we also expect all of the resent messages to be garbled too.

If you think about it, our current protocol is rather naive. By sending the
entire message at once, each transmission is extremely sensitive to errors. If
even a single letter is messed up, we need to resend the _entire message_! The
solution is to break up the message into small pieces. Then each piece has a
higher chance of being transmitted without errors and if an error does occur,
there are fewer data to resend.

We need a new message format for this:

* Break up the message into chunks of 13 bytes. If the last chunk has fewer than
  13 bytes, pad it out to 13 bytes with FF (we will reserve this byte value to
  mean that these bytes are not part of the actual message). For each chunk,
* Precede the chunk with two bytes indicating that chunk's number in the
  sequence i.e. the first chunk has 00 00, then 00 01, then 00 10, etc.
* Follow the chunk with a single byte checksum. Again this is equal to the sum
  of the rest of the bytes in that chunk.
* Add a final chunk where all 13 bytes of message are FF.

Note that with this format, each transmission is 16 bytes (13 bytes of message +
2 bytes for the chunk number + 1 byte checksum). Thus we no longer need bytes
describing the length of each transmission. However we do need some way to
indicate to B that the message is over. Thus we add the "all padding" chunk at
the end of the message. Upon receiving this chunk, B will know that the message
is complete.

We now adapt our protocol to handle the new format:

1. A: Begin with the first 16 byte chunk of message. Every 5 seconds transmit
   the chunk
2. B: Upon receiving a chunk, compute the checksum and check the chunk number.
   If both are correct, respond with 01. Otherwise respond with 00.
3. A: Upon receiving 01 from B, proceed to sending the next chunk of message
   every 5 seconds.
4. A: Upon receiving 00 from B, immediately resend the chunk.
5. A: After sending any chunk of message 30 times, give up.

One notable feature of this protocol is that B now has additional error checking
in the form of the chunk numbers. If it receives a chunk with a number that
isn't one greater than the last chunk, it knows something is wrong.

Alternatively, we could use the chunk numbers to create a protocol with
different strengths. Here's a sketch of a protocol:

1. A: send each chunk once.
2. B: for each received chunk, check the checksum. Keep a list of the chunk
   numbers and whether the checksum was correct.
3. B: after receiving chunks, find N: the largest chunk number that had a valid
   checksum with its chunk. Respond with N and a list of chunk numbers that had
   invalid checksums.
4. A: after receiving B's response, resend all chunks with numbers greater than
   N and all chunks that had invalid checksums

This protocol would be much more complicated to operate, but the advantage for B
is that it doesn't need to respond for every single chunk. If every chunk gets
across successfully, B only needs to respond once at the end saying that it
received the final chunk. This could require a lot less back-and-forth than the
previous protocol.

The chunk numbers can also be used to start assembling the message chunks before
all of them have been received. If B receives chunks 1, 2, 3, 5, 6, and 7 it
might still be able to make use of them before receiving chunk 4 successfully.
